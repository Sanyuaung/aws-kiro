<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kiro Dash</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: 'Arial', sans-serif;
        }
        canvas {
            border: 4px solid #fff;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            background: #87CEEB;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Configuration
        const CONFIG = {
            GRAVITY: 0.6,
            JUMP_VELOCITY: -12,
            MAX_JUMP_HOLD: 0.3,
            SLIDE_DURATION: 0.5,
            BASE_SPEED: 5,
            SPEED_INCREASE: 0.01,
            MAX_SPEED_MULT: 3.0,
            OBSTACLE_INTERVAL: 1.5,
            COIN_INTERVAL: 0.8,
            POWERUP_INTERVAL: 8,
            PLAYER_RADIUS: 20,
            OBSTACLE_RADIUS: 25,
            COIN_RADIUS: 15,
            POWERUP_RADIUS: 20,
            LANE_Y: [250, 450],
            GROUND_Y: 500,
            COIN_VALUE: 10,
            MILESTONE_INTERVAL: 100,
            MILESTONE_POINTS: 50
        };
        
        // Player Class
        class Player {
            constructor() {
                this.x = 150;
                this.y = CONFIG.GROUND_Y;
                this.lane = 0;
                this.vy = 0;
                this.state = 'running';
                this.jumpHoldTime = 0;
                this.slideTimer = 0;
                this.radius = CONFIG.PLAYER_RADIUS;
            }
            
            switchLane(targetLane) {
                if (targetLane !== this.lane) this.lane = targetLane;
            }
            
            jump() {
                if (this.y >= CONFIG.GROUND_Y) {
                    this.vy = CONFIG.JUMP_VELOCITY;
                    this.state = 'jumping';
                    this.jumpHoldTime = 0;
                }
            }
            
            slide() {
                if (this.y >= CONFIG.GROUND_Y && this.state !== 'sliding') {
                    this.state = 'sliding';
                    this.slideTimer = CONFIG.SLIDE_DURATION;
                }
            }
            
            update(dt, jumpHeld) {
                const targetX = CONFIG.LANE_Y[this.lane];
                this.x += (targetX - this.x) * 0.2;
                
                if (this.state === 'jumping') {
                    if (jumpHeld && this.jumpHoldTime < CONFIG.MAX_JUMP_HOLD) {
                        this.vy += CONFIG.JUMP_VELOCITY * 0.1;
                        this.jumpHoldTime += dt;
                    }
                    this.vy += CONFIG.GRAVITY;
                    this.y += this.vy;
                    if (this.y >= CONFIG.GROUND_Y) {
                        this.y = CONFIG.GROUND_Y;
                        this.vy = 0;
                        this.state = 'running';
                    }
                } else if (this.state === 'sliding') {
                    this.slideTimer -= dt;
                    if (this.slideTimer <= 0) this.state = 'running';
                }
            }
            
            getCollisionBounds() {
                return { x: this.x, y: this.y, radius: this.state === 'sliding' ? this.radius * 0.5 : this.radius };
            }
            
            render(ctx) {
                ctx.fillStyle = '#FF6B6B';
                ctx.beginPath();
                const r = this.state === 'sliding' ? this.radius * 0.5 : this.radius;
                ctx.arc(this.x, this.y - r, r, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // Obstacle Class
        class Obstacle {
            constructor(x, lane, type) {
                this.x = x;
                this.lane = lane;
                this.type = type;
                this.y = type === 'ground' ? CONFIG.GROUND_Y : CONFIG.GROUND_Y - 80;
                this.radius = CONFIG.OBSTACLE_RADIUS;
            }
            
            update(speed) {
                this.x -= speed;
            }
            
            isOffScreen() {
                return this.x < -this.radius * 2;
            }
            
            getCollisionBounds() {
                return { x: CONFIG.LANE_Y[this.lane], y: this.y - this.radius, radius: this.radius };
            }
            
            render(ctx) {
                ctx.fillStyle = this.type === 'ground' ? '#8B4513' : '#696969';
                ctx.beginPath();
                ctx.arc(CONFIG.LANE_Y[this.lane], this.y - this.radius, this.radius, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // Coin Class
        class Coin {
            constructor(x, lane) {
                this.x = x;
                this.lane = lane;
                this.y = CONFIG.GROUND_Y - 40;
                this.radius = CONFIG.COIN_RADIUS;
                this.collected = false;
            }
            
            update(speed) {
                this.x -= speed;
            }
            
            isOffScreen() {
                return this.x < -this.radius * 2;
            }
            
            getCollisionBounds() {
                return { x: CONFIG.LANE_Y[this.lane], y: this.y, radius: this.radius };
            }
            
            render(ctx) {
                if (!this.collected) {
                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath();
                    ctx.arc(CONFIG.LANE_Y[this.lane], this.y, this.radius, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }
        
        // PowerUp Class
        class PowerUp {
            constructor(x, lane, type) {
                this.x = x;
                this.lane = lane;
                this.type = type;
                this.y = CONFIG.GROUND_Y - 40;
                this.radius = CONFIG.POWERUP_RADIUS;
                this.collected = false;
            }
            
            update(speed) {
                this.x -= speed;
            }
            
            isOffScreen() {
                return this.x < -this.radius * 2;
            }
            
            getCollisionBounds() {
                return { x: CONFIG.LANE_Y[this.lane], y: this.y, radius: this.radius };
            }
            
            render(ctx) {
                if (!this.collected) {
                    const colors = { shield: '#4ECDC4', speed_boost: '#FF6B6B', coin_multiplier: '#FFD93D', magnet: '#A8E6CF' };
                    ctx.fillStyle = colors[this.type] || '#FFF';
                    ctx.fillRect(CONFIG.LANE_Y[this.lane] - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);
                }
            }
        }
        
        // ActivePowerUp Class
        class ActivePowerUp {
            constructor(type, duration) {
                this.type = type;
                this.duration = duration;
                this.maxDuration = duration;
            }
            
            update(dt) {
                this.duration -= dt;
            }
            
            isExpired() {
                return this.duration <= 0;
            }
        }
        
        // EntityManager Class
        class EntityManager {
            constructor() {
                this.obstacles = [];
                this.coins = [];
                this.powerUps = [];
                this.obstacleTimer = 0;
                this.coinTimer = 0;
                this.powerUpTimer = 0;
            }
            
            updateSpawning(dt, speed) {
                this.obstacleTimer -= dt;
                if (this.obstacleTimer <= 0) {
                    const lane = Math.random() < 0.5 ? 0 : 1;
                    const type = Math.random() < 0.6 ? 'ground' : 'air';
                    this.obstacles.push(new Obstacle(canvas.width, lane, type));
                    this.obstacleTimer = CONFIG.OBSTACLE_INTERVAL / (speed / CONFIG.BASE_SPEED);
                }
                
                this.coinTimer -= dt;
                if (this.coinTimer <= 0) {
                    const lane = Math.random() < 0.5 ? 0 : 1;
                    this.coins.push(new Coin(canvas.width, lane));
                    this.coinTimer = CONFIG.COIN_INTERVAL / (speed / CONFIG.BASE_SPEED);
                }
                
                this.powerUpTimer -= dt;
                if (this.powerUpTimer <= 0) {
                    const lane = Math.random() < 0.5 ? 0 : 1;
                    const types = ['shield', 'speed_boost', 'coin_multiplier', 'magnet'];
                    const type = types[Math.floor(Math.random() * types.length)];
                    this.powerUps.push(new PowerUp(canvas.width, lane, type));
                    this.powerUpTimer = CONFIG.POWERUP_INTERVAL / (speed / CONFIG.BASE_SPEED);
                }
            }
            
            updateAll(speed) {
                this.obstacles.forEach(o => o.update(speed));
                this.coins.forEach(c => c.update(speed));
                this.powerUps.forEach(p => p.update(speed));
                
                this.obstacles = this.obstacles.filter(o => !o.isOffScreen());
                this.coins = this.coins.filter(c => !c.isOffScreen());
                this.powerUps = this.powerUps.filter(p => !p.isOffScreen());
            }
            
            clearAll() {
                this.obstacles = [];
                this.coins = [];
                this.powerUps = [];
            }
        }
        
        // CollisionDetector Class
        class CollisionDetector {
            static checkCircle(b1, b2) {
                const dx = b1.x - b2.x;
                const dy = b1.y - b2.y;
                return Math.sqrt(dx * dx + dy * dy) < (b1.radius + b2.radius);
            }
        }
        
        // ScoreManager Class
        class ScoreManager {
            constructor() {
                this.score = 0;
                this.distance = 0;
                this.highScore = parseInt(localStorage.getItem('kiro-dash-high-score') || '0');
                this.lastMilestone = 0;
                this.coinMultiplier = 1;
            }
            
            addCoinScore() {
                this.score += CONFIG.COIN_VALUE * this.coinMultiplier;
            }
            
            updateDistance(dt, speed) {
                this.distance += speed * dt * 0.1;
                const milestone = Math.floor(this.distance / CONFIG.MILESTONE_INTERVAL);
                if (milestone > this.lastMilestone) {
                    this.score += CONFIG.MILESTONE_POINTS;
                    this.lastMilestone = milestone;
                }
            }
            
            updateHighScore() {
                if (this.score > this.highScore) {
                    this.highScore = this.score;
                    localStorage.setItem('kiro-dash-high-score', this.highScore.toString());
                }
            }
            
            reset() {
                this.score = 0;
                this.distance = 0;
                this.lastMilestone = 0;
                this.coinMultiplier = 1;
            }
        }
        
        // AudioManager Class
        class AudioManager {
            constructor() {
                this.sounds = {
                    jump: new Audio('assets/jump.wav'),
                    gameOver: new Audio('assets/game_over.wav')
                };
                this.muted = false;
            }
            
            play(name) {
                if (!this.muted && this.sounds[name]) {
                    this.sounds[name].currentTime = 0;
                    this.sounds[name].play().catch(() => {});
                }
            }
        }
        
        // SpeedController Class
        class SpeedController {
            constructor() {
                this.multiplier = 1.0;
            }
            
            update(dt) {
                this.multiplier = Math.min(this.multiplier + CONFIG.SPEED_INCREASE * dt, CONFIG.MAX_SPEED_MULT);
            }
            
            getCurrentSpeed() {
                return CONFIG.BASE_SPEED * this.multiplier;
            }
            
            reset() {
                this.multiplier = 1.0;
            }
        }
        
        // Game Class
        class Game {
            constructor() {
                this.state = 'MENU';
                this.player = new Player();
                this.entityManager = new EntityManager();
                this.scoreManager = new ScoreManager();
                this.audioManager = new AudioManager();
                this.speedController = new SpeedController();
                this.activePowerUps = [];
                this.keys = {};
                this.setupInput();
            }
            
            setupInput() {
                window.addEventListener('keydown', e => {
                    this.keys[e.code] = true;
                    if (this.state === 'MENU' && e.code === 'Space') this.start();
                    if (this.state === 'GAME_OVER' && e.code === 'Space') this.restart();
                    if (this.state === 'PLAYING') {
                        if (e.code === 'Space') {
                            this.player.jump();
                            this.audioManager.play('jump');
                        }
                        if (e.code === 'ArrowDown' || e.code === 'ArrowUp') this.player.slide();
                    }
                });
                window.addEventListener('keyup', e => this.keys[e.code] = false);
            }
            
            start() {
                this.state = 'PLAYING';
                this.lastTime = performance.now();
                requestAnimationFrame(t => this.gameLoop(t));
            }
            
            restart() {
                this.player = new Player();
                this.entityManager.clearAll();
                this.scoreManager.reset();
                this.speedController.reset();
                this.activePowerUps = [];
                this.start();
            }
            
            update(dt) {
                if (this.state !== 'PLAYING') return;
                
                // Input
                if (this.keys['ArrowLeft'] || this.keys['KeyA']) this.player.switchLane(0);
                if (this.keys['ArrowRight'] || this.keys['KeyD']) this.player.switchLane(1);
                
                // Update systems
                this.player.update(dt, this.keys['Space']);
                this.speedController.update(dt);
                const speed = this.speedController.getCurrentSpeed();
                this.entityManager.updateSpawning(dt, speed);
                this.entityManager.updateAll(speed);
                this.scoreManager.updateDistance(dt, speed);
                
                // Update power-ups
                this.activePowerUps.forEach(p => p.update(dt));
                this.activePowerUps = this.activePowerUps.filter(p => !p.isExpired());
                this.scoreManager.coinMultiplier = this.activePowerUps.some(p => p.type === 'coin_multiplier') ? 2 : 1;
                
                // Collisions
                const playerBounds = this.player.getCollisionBounds();
                
                for (const obs of this.entityManager.obstacles) {
                    if (obs.lane === this.player.lane && CollisionDetector.checkCircle(playerBounds, obs.getCollisionBounds())) {
                        const hasShield = this.activePowerUps.findIndex(p => p.type === 'shield');
                        if (hasShield >= 0) {
                            this.activePowerUps.splice(hasShield, 1);
                            this.entityManager.obstacles = this.entityManager.obstacles.filter(o => o !== obs);
                        } else {
                            this.gameOver();
                            return;
                        }
                    }
                }
                
                for (const coin of this.entityManager.coins) {
                    if (!coin.collected && coin.lane === this.player.lane && CollisionDetector.checkCircle(playerBounds, coin.getCollisionBounds())) {
                        coin.collected = true;
                        this.scoreManager.addCoinScore();
                    }
                }
                
                for (const pu of this.entityManager.powerUps) {
                    if (!pu.collected && pu.lane === this.player.lane && CollisionDetector.checkCircle(playerBounds, pu.getCollisionBounds())) {
                        pu.collected = true;
                        const durations = { shield: 15, speed_boost: 10, coin_multiplier: 12, magnet: 8 };
                        this.activePowerUps.push(new ActivePowerUp(pu.type, durations[pu.type]));
                    }
                }
            }
            
            gameOver() {
                this.state = 'GAME_OVER';
                this.audioManager.play('gameOver');
                this.scoreManager.updateHighScore();
            }
            
            render() {
                // Clear
                ctx.fillStyle = '#87CEEB';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Background
                ctx.fillStyle = '#228B22';
                ctx.fillRect(0, CONFIG.GROUND_Y, canvas.width, canvas.height - CONFIG.GROUND_Y);
                
                // Entities
                this.entityManager.obstacles.forEach(o => o.render(ctx));
                this.entityManager.coins.forEach(c => c.render(ctx));
                this.entityManager.powerUps.forEach(p => p.render(ctx));
                this.player.render(ctx);
                
                // UI
                if (this.state === 'PLAYING') {
                    ctx.fillStyle = '#000';
                    ctx.font = '24px Arial';
                    ctx.fillText(`Score: ${Math.floor(this.scoreManager.score)}`, 10, 30);
                    ctx.fillText(`Distance: ${Math.floor(this.scoreManager.distance)}m`, 10, 60);
                    
                    this.activePowerUps.forEach((p, i) => {
                        ctx.fillText(`${p.type}: ${Math.ceil(p.duration)}s`, canvas.width - 200, 30 + i * 30);
                    });
                } else if (this.state === 'MENU') {
                    ctx.fillStyle = '#000';
                    ctx.font = '48px Arial';
                    ctx.fillText('KIRO DASH', canvas.width / 2 - 140, canvas.height / 2 - 50);
                    ctx.font = '24px Arial';
                    ctx.fillText('Press SPACE to Start', canvas.width / 2 - 120, canvas.height / 2 + 20);
                    ctx.font = '18px Arial';
                    ctx.fillText('Arrow Keys / A-D: Move  |  Space: Jump  |  Up/Down: Slide', canvas.width / 2 - 280, canvas.height / 2 + 60);
                } else if (this.state === 'GAME_OVER') {
                    ctx.fillStyle = '#000';
                    ctx.font = '48px Arial';
                    ctx.fillText('GAME OVER', canvas.width / 2 - 140, canvas.height / 2 - 50);
                    ctx.font = '24px Arial';
                    ctx.fillText(`Score: ${Math.floor(this.scoreManager.score)}`, canvas.width / 2 - 60, canvas.height / 2 + 10);
                    ctx.fillText(`Distance: ${Math.floor(this.scoreManager.distance)}m`, canvas.width / 2 - 80, canvas.height / 2 + 40);
                    ctx.fillText(`High Score: ${this.scoreManager.highScore}`, canvas.width / 2 - 90, canvas.height / 2 + 70);
                    ctx.fillText('Press SPACE to Restart', canvas.width / 2 - 130, canvas.height / 2 + 110);
                }
            }
            
            gameLoop(currentTime) {
                const dt = Math.min((currentTime - this.lastTime) / 1000, 0.1);
                this.lastTime = currentTime;
                
                this.update(dt);
                this.render();
                
                requestAnimationFrame(t => this.gameLoop(t));
            }
        }
        
        // Initialize
        const game = new Game();
    </script>
</body>
</html>
